const path = require('path');
const fs = require('fs').promises;
const File = require('../models/File');
const Usage = require('../models/Usage');

// Helper function to create document file record
const createDocumentFile = async (filename, originalName, mimeType, size, userId, category, metadata = {}) => {
  const file = await File.create({
    filename,
    originalName,
    mimeType,
    size,
    path: path.join('uploads', filename),
    url: `/uploads/${filename}`,
    user: userId,
    type: 'document',
    category,
    status: 'completed',
    metadata
  });

  return file;
};

// @desc    Convert text to DOC
// @route   POST /api/documents/convert/text-to-doc
// @access  Private
const textToDoc = async (req, res) => {
  try {
    const { text, title = 'Document', options = {} } = req.body;

    if (!text) {
      return res.status(400).json({
        success: false,
        error: 'Text content is required'
      });
    }

    // Check feature access
    if (!req.user.canUseFeature('text-to-doc')) {
      return res.status(403).json({
        success: false,
        error: 'Feature limit exceeded. Please upgrade your plan.'
      });
    }

    // Generate filename
    const timestamp = Date.now();
    const filename = `doc-${timestamp}.doc`;
    const outputPath = path.join('uploads', filename);

    // Create DOC content (simple text format for now)
    // In production, you might want to use a library like 'docx' for better formatting
    const docContent = `
${title}

${text}

Generated on: ${new Date().toLocaleString()}
Generated by: SaaS Platform
    `.trim();

    // Write file
    await fs.writeFile(outputPath, docContent, 'utf8');

    // Get file stats
    const stats = await fs.stat(outputPath);

    // Create file record
    const file = await createDocumentFile(
      filename,
      `${title}.doc`,
      'application/msword',
      stats.size,
      req.user._id,
      'converted',
      {
        format: 'doc',
        title,
        textLength: text.length,
        conversion: 'text-to-doc'
      }
    );

    // Update user storage usage
    req.user.addStorageUsage(stats.size);
    await req.user.save();

    // Increment feature usage
    req.user.incrementFeatureUsage('text-to-doc');
    await req.user.save();

    // Log usage
    await Usage.create({
      user: req.user._id,
      feature: 'text-to-doc',
      file: file._id,
      metadata: {
        fileSize: stats.size,
        inputFormat: 'text',
        outputFormat: 'doc',
        parameters: { title, options },
        success: true
      },
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    });

    res.status(200).json({
      success: true,
      message: 'Text converted to DOC successfully',
      data: {
        file: {
          id: file._id,
          filename: file.filename,
          originalName: file.originalName,
          size: file.size,
          url: file.url,
          metadata: file.metadata
        },
        downloadUrl: `/api/documents/download/${file._id}`
      }
    });
  } catch (error) {
    console.error('Text to DOC conversion error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to convert text to DOC'
    });
  }
};

// @desc    Convert text to PDF
// @route   POST /api/documents/convert/text-to-pdf
// @access  Private
const textToPdf = async (req, res) => {
  try {
    const { text, title = 'Document', options = {} } = req.body;

    if (!text) {
      return res.status(400).json({
        success: false,
        error: 'Text content is required'
      });
    }

    // Check feature access
    if (!req.user.canUseFeature('text-to-pdf')) {
      return res.status(403).json({
        success: false,
        error: 'Feature limit exceeded. Please upgrade your plan.'
      });
    }

    // Generate filename
    const timestamp = Date.now();
    const filename = `pdf-${timestamp}.pdf`;
    const outputPath = path.join('uploads', filename);

    // Create PDF content using PDFKit
    const PDFDocument = require('pdfkit');
    const doc = new PDFDocument();

    // Pipe to file
    const stream = require('fs').createWriteStream(outputPath);
    doc.pipe(stream);

    // Add content to PDF
    doc.fontSize(18).text(title, { align: 'center' });
    doc.moveDown();
    doc.fontSize(12).text(text);
    doc.moveDown();
    doc.fontSize(10).text(`Generated on: ${new Date().toLocaleString()}`, { align: 'center' });

    // Finalize PDF
    doc.end();

    // Wait for file to be written
    await new Promise((resolve, reject) => {
      stream.on('finish', resolve);
      stream.on('error', reject);
    });

    // Get file stats
    const stats = await fs.stat(outputPath);

    // Create file record
    const file = await createDocumentFile(
      filename,
      `${title}.pdf`,
      'application/pdf',
      stats.size,
      req.user._id,
      'converted',
      {
        format: 'pdf',
        title,
        textLength: text.length,
        conversion: 'text-to-pdf',
        pages: 1
      }
    );

    // Update user storage usage
    req.user.addStorageUsage(stats.size);
    await req.user.save();

    // Increment feature usage
    req.user.incrementFeatureUsage('text-to-pdf');
    await req.user.save();

    // Log usage
    await Usage.create({
      user: req.user._id,
      feature: 'text-to-pdf',
      file: file._id,
      metadata: {
        fileSize: stats.size,
        inputFormat: 'text',
        outputFormat: 'pdf',
        parameters: { title, options },
        success: true
      },
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    });

    res.status(200).json({
      success: true,
      message: 'Text converted to PDF successfully',
      data: {
        file: {
          id: file._id,
          filename: file.filename,
          originalName: file.originalName,
          size: file.size,
          url: file.url,
          metadata: file.metadata
        },
        downloadUrl: `/api/documents/download/${file._id}`
      }
    });
  } catch (error) {
    console.error('Text to PDF conversion error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to convert text to PDF'
    });
  }
};

// @desc    Convert text to Excel
// @route   POST /api/documents/convert/text-to-excel
// @access  Private
const textToExcel = async (req, res) => {
  try {
    const { text, title = 'Spreadsheet', options = {} } = req.body;

    if (!text) {
      return res.status(400).json({
        success: false,
        error: 'Text content is required'
      });
    }

    // Check feature access
    if (!req.user.canUseFeature('text-to-excel')) {
      return res.status(403).json({
        success: false,
        error: 'Feature limit exceeded. Please upgrade your plan.'
      });
    }

    // Generate filename
    const timestamp = Date.now();
    const filename = `excel-${timestamp}.xlsx`;
    const outputPath = path.join('uploads', filename);

    // Create Excel workbook using ExcelJS
    const ExcelJS = require('exceljs');
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Sheet 1');

    // Add title
    worksheet.getCell('A1').value = title;
    worksheet.getCell('A1').font = { bold: true, size: 14 };

    // Split text into rows (assuming line-separated data)
    const lines = text.split('\n').filter(line => line.trim());
    let currentRow = 3;

    lines.forEach(line => {
      const columns = line.split(/[,;]/).map(col => col.trim());
      columns.forEach((col, index) => {
        worksheet.getCell(currentRow, index + 1).value = col;
      });
      currentRow++;
    });

    // Auto-fit columns
    worksheet.columns.forEach(column => {
      column.width = 15;
    });

    // Write file
    await workbook.xlsx.writeFile(outputPath);

    // Get file stats
    const stats = await fs.stat(outputPath);

    // Create file record
    const file = await createDocumentFile(
      filename,
      `${title}.xlsx`,
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      stats.size,
      req.user._id,
      'converted',
      {
        format: 'xlsx',
        title,
        textLength: text.length,
        conversion: 'text-to-excel',
        rows: lines.length,
        columns: lines.length > 0 ? lines[0].split(/[,;]/).length : 0
      }
    );

    // Update user storage usage
    req.user.addStorageUsage(stats.size);
    await req.user.save();

    // Increment feature usage
    req.user.incrementFeatureUsage('text-to-excel');
    await req.user.save();

    // Log usage
    await Usage.create({
      user: req.user._id,
      feature: 'text-to-excel',
      file: file._id,
      metadata: {
        fileSize: stats.size,
        inputFormat: 'text',
        outputFormat: 'xlsx',
        parameters: { title, options },
        success: true
      },
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    });

    res.status(200).json({
      success: true,
      message: 'Text converted to Excel successfully',
      data: {
        file: {
          id: file._id,
          filename: file.filename,
          originalName: file.originalName,
          size: file.size,
          url: file.url,
          metadata: file.metadata
        },
        downloadUrl: `/api/documents/download/${file._id}`
      }
    });
  } catch (error) {
    console.error('Text to Excel conversion error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to convert text to Excel'
    });
  }
};

// @desc    Convert Excel to CSV
// @route   POST /api/documents/convert/excel-to-csv
// @access  Private
const excelToCsv = async (req, res) => {
  try {
    const { fileId, options = {} } = req.body;

    if (!fileId) {
      return res.status(400).json({
        success: false,
        error: 'File ID is required'
      });
    }

    // Get original file
    const originalFile = await File.findById(fileId);
    if (!originalFile || originalFile.user.toString() !== req.user._id.toString()) {
      return res.status(404).json({
        success: false,
        error: 'File not found'
      });
    }

    // Check feature access
    if (!req.user.canUseFeature('excel-to-csv')) {
      return res.status(403).json({
        success: false,
        error: 'Feature limit exceeded. Please upgrade your plan.'
      });
    }

    // Generate filename
    const timestamp = Date.now();
    const filename = `csv-${timestamp}.csv`;
    const outputPath = path.join('uploads', filename);

    // Read Excel file and convert to CSV
    const ExcelJS = require('exceljs');
    const workbook = new ExcelJS.Workbook();

    await workbook.xlsx.readFile(originalFile.path);

    let csvContent = '';
    workbook.eachSheet((worksheet) => {
      // Convert worksheet to CSV format
      let csv = '';

      worksheet.eachRow((row, rowNumber) => {
        const values = row.values
          .slice(1) // Remove the first empty element
          .map(value => {
            if (typeof value === 'string' && value.includes(',')) {
              return `"${value}"`;
            }
            return value || '';
          });
        csv += values.join(',') + '\n';
      });

      csvContent += csv;
    });

    // Write CSV file
    await fs.writeFile(outputPath, csvContent, 'utf8');

    // Get file stats
    const stats = await fs.stat(outputPath);

    // Create file record
    const file = await createDocumentFile(
      filename,
      `converted-${originalFile.originalName.replace(/\.[^.]+$/, '.csv')}`,
      'text/csv',
      stats.size,
      req.user._id,
      'converted',
      {
        format: 'csv',
        conversion: 'excel-to-csv',
        originalFileId: originalFile._id,
        rows: csvContent.split('\n').length - 1,
        columns: csvContent.split('\n')[0] ? csvContent.split('\n')[0].split(',').length : 0
      }
    );

    // Update original file
    originalFile.relatedFiles.push(file._id);
    await originalFile.save();

    // Update user storage usage
    req.user.addStorageUsage(stats.size);
    await req.user.save();

    // Increment feature usage
    req.user.incrementFeatureUsage('excel-to-csv');
    await req.user.save();

    // Log usage
    await Usage.create({
      user: req.user._id,
      feature: 'excel-to-csv',
      file: file._id,
      metadata: {
        fileSize: stats.size,
        inputFormat: 'xlsx',
        outputFormat: 'csv',
        parameters: options,
        success: true
      },
      ipAddress: req.ip,
      userAgent: req.get('User-Agent')
    });

    res.status(200).json({
      success: true,
      message: 'Excel converted to CSV successfully',
      data: {
        originalFile: {
          id: originalFile._id,
          filename: originalFile.filename
        },
        convertedFile: {
          id: file._id,
          filename: file.filename,
          originalName: file.originalName,
          size: file.size,
          url: file.url,
          metadata: file.metadata
        },
        downloadUrl: `/api/documents/download/${file._id}`
      }
    });
  } catch (error) {
    console.error('Excel to CSV conversion error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to convert Excel to CSV'
    });
  }
};

module.exports = {
  textToDoc,
  textToPdf,
  textToExcel,
  excelToCsv
};